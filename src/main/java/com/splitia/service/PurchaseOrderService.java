package com.splitia.service;

import com.splitia.dto.request.CreatePurchaseOrderItemRequest;
import com.splitia.dto.request.CreatePurchaseOrderRequest;
import com.splitia.dto.response.PurchaseOrderResponse;
import com.splitia.exception.ResourceNotFoundException;
import com.splitia.mapper.PurchaseOrderMapper;
import com.splitia.model.User;
import com.splitia.model.enums.PurchaseOrderStatus;
import com.splitia.model.enums.StockMovementType;
import com.splitia.model.inventory.Product;
import com.splitia.model.inventory.Stock;
import com.splitia.model.inventory.StockMovement;
import com.splitia.model.procurement.PurchaseOrder;
import com.splitia.model.procurement.PurchaseOrderItem;
import com.splitia.model.procurement.Vendor;
import com.splitia.repository.*;
import com.splitia.service.websocket.WebSocketNotificationService;
import lombok.RequiredArgsConstructor;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.Pageable;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import java.math.BigDecimal;
import java.time.LocalDate;
import java.time.LocalDateTime;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.UUID;

@Service
@RequiredArgsConstructor
public class PurchaseOrderService {
    
    private final PurchaseOrderRepository purchaseOrderRepository;
    private final VendorRepository vendorRepository;
    private final ProductRepository productRepository;
    private final StockRepository stockRepository;
    private final StockMovementRepository stockMovementRepository;
    private final UserRepository userRepository;
    private final PurchaseOrderMapper purchaseOrderMapper;
    private final WebSocketNotificationService webSocketNotificationService;
    
    @Transactional(readOnly = true)
    public Page<PurchaseOrderResponse> getAllPurchaseOrders(Pageable pageable, PurchaseOrderStatus status, UUID vendorId) {
        if (status != null) {
            return purchaseOrderRepository.findByStatus(status, pageable)
                    .map(purchaseOrderMapper::toResponse);
        }
        if (vendorId != null) {
            return purchaseOrderRepository.findByVendorId(vendorId, pageable)
                    .map(purchaseOrderMapper::toResponse);
        }
        return purchaseOrderRepository.findAllActive(pageable)
                .map(purchaseOrderMapper::toResponse);
    }
    
    @Transactional(readOnly = true)
    public PurchaseOrderResponse getPurchaseOrderById(UUID id) {
        PurchaseOrder purchaseOrder = purchaseOrderRepository.findByIdAndDeletedAtIsNull(id)
                .orElseThrow(() -> new ResourceNotFoundException("PurchaseOrder", "id", id));
        return purchaseOrderMapper.toResponse(purchaseOrder);
    }
    
    @Transactional
    public PurchaseOrderResponse createPurchaseOrder(CreatePurchaseOrderRequest request, UUID createdById) {
        User createdBy = userRepository.findByIdAndDeletedAtIsNull(createdById)
                .orElseThrow(() -> new ResourceNotFoundException("User", "id", createdById));
        
        Vendor vendor = vendorRepository.findByIdAndDeletedAtIsNull(request.getVendorId())
                .orElseThrow(() -> new ResourceNotFoundException("Vendor", "id", request.getVendorId()));
        
        PurchaseOrder purchaseOrder = new PurchaseOrder();
        purchaseOrder.setOrderNumber(request.getOrderNumber()); // Auto-generated by trigger if null
        purchaseOrder.setVendor(vendor);
        purchaseOrder.setOrderDate(request.getOrderDate());
        purchaseOrder.setExpectedDate(request.getExpectedDate());
        purchaseOrder.setStatus(request.getStatus() != null ? request.getStatus() : PurchaseOrderStatus.DRAFT);
        purchaseOrder.setNotes(request.getNotes());
        purchaseOrder.setCreatedBy(createdBy);
        
        BigDecimal total = BigDecimal.ZERO;
        List<PurchaseOrderItem> items = new ArrayList<>();
        for (CreatePurchaseOrderItemRequest itemRequest : request.getItems()) {
            Product product = productRepository.findByIdAndDeletedAtIsNull(itemRequest.getProductId())
                    .orElseThrow(() -> new ResourceNotFoundException("Product", "id", itemRequest.getProductId()));
            
            PurchaseOrderItem item = new PurchaseOrderItem();
            item.setPurchaseOrder(purchaseOrder);
            item.setProduct(product);
            item.setQuantity(itemRequest.getQuantity());
            item.setUnitPrice(itemRequest.getUnitPrice());
            item.setTotal(itemRequest.getUnitPrice().multiply(BigDecimal.valueOf(itemRequest.getQuantity())));
            items.add(item);
            total = total.add(item.getTotal());
        }
        purchaseOrder.setTotal(total);
        purchaseOrder.setItems(items);
        
        purchaseOrder = purchaseOrderRepository.save(purchaseOrder);
        PurchaseOrderResponse response = purchaseOrderMapper.toResponse(purchaseOrder);
        
        Map<String, Object> data = new HashMap<>();
        data.put("purchaseOrder", response);
        webSocketNotificationService.notifyPurchaseOrderCreated(purchaseOrder.getId(), data, createdById);
        
        return response;
    }
    
    @Transactional
    public PurchaseOrderResponse receivePurchaseOrder(UUID id, Map<UUID, Integer> receivedQuantities) {
        PurchaseOrder purchaseOrder = purchaseOrderRepository.findByIdAndDeletedAtIsNull(id)
                .orElseThrow(() -> new ResourceNotFoundException("PurchaseOrder", "id", id));
        
        if (purchaseOrder.getStatus() != PurchaseOrderStatus.ORDERED) {
            throw new com.splitia.exception.BadRequestException("Purchase order must be in ORDERED status to receive");
        }
        
        boolean allReceived = true;
        for (PurchaseOrderItem item : purchaseOrder.getItems()) {
            Integer receivedQty = receivedQuantities.getOrDefault(item.getId(), 0);
            item.setReceivedQuantity(item.getReceivedQuantity() + receivedQty);
            
            if (item.getReceivedQuantity() < item.getQuantity()) {
                allReceived = false;
            }
            
            // Update stock
            Stock stock = stockRepository.findByProductId(item.getProduct().getId())
                    .orElseThrow(() -> new ResourceNotFoundException("Stock", "productId", item.getProduct().getId()));
            
            StockMovement movement = new StockMovement();
            movement.setProduct(item.getProduct());
            movement.setType(StockMovementType.IN);
            movement.setQuantity(receivedQty);
            movement.setReason("Purchase order receipt: " + purchaseOrder.getOrderNumber());
            movement.setReference(purchaseOrder.getOrderNumber());
            movement.setDate(LocalDate.now());
            stockMovementRepository.save(movement);
            
            stock.setQuantity(stock.getQuantity() + receivedQty);
            stockRepository.save(stock);
        }
        
        purchaseOrder.setStatus(allReceived ? PurchaseOrderStatus.RECEIVED : PurchaseOrderStatus.ORDERED);
        purchaseOrder = purchaseOrderRepository.save(purchaseOrder);
        
        PurchaseOrderResponse response = purchaseOrderMapper.toResponse(purchaseOrder);
        
        Map<String, Object> data = new HashMap<>();
        data.put("purchaseOrder", response);
        webSocketNotificationService.notifyPurchaseOrderStatusChanged(
            purchaseOrder.getId(), 
            PurchaseOrderStatus.ORDERED.name(), 
            purchaseOrder.getStatus().name(), 
            getCurrentUserId()
        );
        
        return response;
    }
    
    @Transactional
    public PurchaseOrderResponse updatePurchaseOrderStatus(UUID id, PurchaseOrderStatus status) {
        PurchaseOrder purchaseOrder = purchaseOrderRepository.findByIdAndDeletedAtIsNull(id)
                .orElseThrow(() -> new ResourceNotFoundException("PurchaseOrder", "id", id));
        
        PurchaseOrderStatus oldStatus = purchaseOrder.getStatus();
        purchaseOrder.setStatus(status);
        purchaseOrder = purchaseOrderRepository.save(purchaseOrder);
        
        PurchaseOrderResponse response = purchaseOrderMapper.toResponse(purchaseOrder);
        
        Map<String, Object> data = new HashMap<>();
        data.put("purchaseOrder", response);
        webSocketNotificationService.notifyPurchaseOrderStatusChanged(
            purchaseOrder.getId(), 
            oldStatus.name(), 
            status.name(), 
            getCurrentUserId()
        );
        
        return response;
    }
    
    @Transactional
    public void deletePurchaseOrder(UUID id, boolean hardDelete) {
        if (hardDelete) {
            purchaseOrderRepository.deleteById(id);
        } else {
            PurchaseOrder purchaseOrder = purchaseOrderRepository.findByIdAndDeletedAtIsNull(id)
                    .orElseThrow(() -> new ResourceNotFoundException("PurchaseOrder", "id", id));
            purchaseOrder.setDeletedAt(LocalDateTime.now());
            purchaseOrderRepository.save(purchaseOrder);
        }
    }
    
    private UUID getCurrentUserId() {
        try {
            org.springframework.security.core.Authentication authentication = 
                org.springframework.security.core.context.SecurityContextHolder.getContext().getAuthentication();
            if (authentication != null && authentication.getPrincipal() instanceof com.splitia.security.CustomUserDetails) {
                com.splitia.security.CustomUserDetails userDetails = 
                    (com.splitia.security.CustomUserDetails) authentication.getPrincipal();
                return userDetails.getUserId();
            }
        } catch (Exception e) {
        }
        return null;
    }
}

